#!/usr/bin/env python3
# ePHI Lockbox: Encrypt/Decrypt tool for secure healthcare files

import os
import sys
import argparse
import base64
import hashlib
import logging
from getpass import getpass
from pathlib import Path
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.backends import default_backend

# Constants
KEYFILE = "ephilockbox.key"
LOGFILE = "logs/activity_log.txt"
SALT = b'ephi-salt-value'  # Fixed salt for demo (replace with secure random salt in production)

# Set up logging
os.makedirs("logs", exist_ok=True)
logging.basicConfig(filename=LOGFILE, level=logging.INFO, format='%(asctime)s %(message)s')

# === KEY MANAGEMENT ===
def generate_key_from_password(password: str) -> bytes:
    """Derive a Fernet key from a password."""
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=SALT,
        iterations=100_000,
        backend=default_backend()
    )
    return base64.urlsafe_b64encode(kdf.derive(password.encode()))

def get_fernet_key(password_mode: bool) -> Fernet:
    """Get or generate Fernet key."""
    if password_mode:
        password = getpass("Enter encryption password: ")
        key = generate_key_from_password(password)
    else:
        if not os.path.exists(KEYFILE):
            key = Fernet.generate_key()
            with open(KEYFILE, 'wb') as f:
                f.write(key)
        else:
            with open(KEYFILE, 'rb') as f:
                key = f.read()
    return Fernet(key)

# === ENCRYPTION ===
def encrypt_file(file_path: str, fernet: Fernet):
    output_path = file_path + '.enc'
    try:
        with open(file_path, 'rb') as f:
            data = f.read()
        encrypted = fernet.encrypt(data)
        with open(output_path, 'wb') as f:
            f.write(encrypted)
        logging.info(f"Encrypted: {file_path} -> {output_path}")
        print(f"[+] Encrypted: {file_path}")
    except Exception as e:
        print(f"[!] Failed to encrypt {file_path}: {e}")

# === DECRYPTION ===
def decrypt_file(file_path: str, fernet: Fernet):
    if not file_path.endswith('.enc'):
        print(f"[!] Skipping {file_path}: Not an .enc file")
        return
    output_path = file_path.replace('.enc', '')
    try:
        with open(file_path, 'rb') as f:
            encrypted = f.read()
        decrypted = fernet.decrypt(encrypted)
        with open(output_path, 'wb') as f:
            f.write(decrypted)
        logging.info(f"Decrypted: {file_path} -> {output_path}")
        print(f"[+] Decrypted: {file_path}")
    except Exception as e:
        print(f"[!] Failed to decrypt {file_path}: {e}")

# === DIRECTORY PROCESSING ===
def process_directory(path: str, fernet: Fernet, mode: str):
    for root, _, files in os.walk(path):
        for file in files:
            full_path = os.path.join(root, file)
            if mode == 'encrypt' and not file.endswith('.enc'):
                encrypt_file(full_path, fernet)
            elif mode == 'decrypt' and file.endswith('.enc'):
                decrypt_file(full_path, fernet)

# === MAIN CLI ===
def main():
    parser = argparse.ArgumentParser(description="ePHI Lockbox - Encrypt/Decrypt Files")
    parser.add_argument("mode", choices=["encrypt", "decrypt"], help="Encrypt or decrypt mode")
    parser.add_argument("-f", "--file", help="Single file to process")
    parser.add_argument("-d", "--directory", help="Directory to process recursively")
    parser.add_argument("--password", action="store_true", help="Use password-derived encryption key")
    args = parser.parse_args()

    fernet = get_fernet_key(password_mode=args.password)

    if args.file:
        if args.mode == "encrypt":
            encrypt_file(args.file, fernet)
        else:
            decrypt_file(args.file, fernet)

    elif args.directory:
        process_directory(args.directory, fernet, mode=args.mode)
    else:
        parser.error("You must specify either a file (-f) or directory (-d).")

if __name__ == "__main__":
    main()
